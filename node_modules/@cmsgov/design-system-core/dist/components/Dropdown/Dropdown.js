"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Dropdown = void 0;

var _FormLabel = _interopRequireDefault(require("../FormLabel/FormLabel"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _lodash = _interopRequireDefault(require("lodash.uniqueid"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var Dropdown = /*#__PURE__*/function (_React$PureComponent) {
  _inherits(Dropdown, _React$PureComponent);

  function Dropdown(props) {
    var _this;

    _classCallCheck(this, Dropdown);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Dropdown).call(this, props));

    if (process.env.NODE_ENV !== 'production') {
      if (props.fieldRef) {
        console.warn("[Deprecated]: Please remove the 'fieldRef' prop in <Dropdown>, use 'inputRef' instead. This prop is no longer supported and will be removed in a future release.");
      }

      if (props.children && props.options.length > 0) {
        console.warn("Cannot use 'options' and 'children' React properties at the same time in the <Dropdown> component. Please use 'children' for custom options and 'options' for general cases");
      } // 'ariaLabel' is provided with a `label` prop that is not an empty string


      if (props.ariaLabel && (typeof props.label !== 'string' || props.label.length > 0)) {
        console.warn("Cannot use 'ariaLabel' and 'label' React properties together in the <Dropdown> component. If the 'label' prop is used, it should be written for all users so that an 'ariaLabel' is not needed. The 'ariaLabel' prop is intended to be used only when the input is missing an input label (i.e when an empty string is provided for the 'label' prop)");
      } // An empty string `label` is provided without a corresponding `ariaLabel` prop


      if (!props.ariaLabel && typeof props.label === 'string' && props.label.length === 0) {
        console.warn("Please provide an 'ariaLabel' when using the <Dropdown> component without a 'label' prop.");
      }
    }

    return _this;
  }

  _createClass(Dropdown, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (this.props.focusTrigger) {
        this.focusRef && this.focusRef.focus();
      }
    }
  }, {
    key: "id",
    value: function id() {
      // Use provided custom id
      if (this.props.id) {
        return this.props.id;
      } // Use generated id


      if (!this._id) {
        // Cache the ID so we're not regenerating it on each method call
        this._id = (0, _lodash.default)("select_".concat(this.props.name, "_"));
      }

      return this._id;
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      /* eslint-disable prefer-const */
      var _this$props = this.props,
          ariaLabel = _this$props.ariaLabel,
          className = _this$props.className,
          children = _this$props.children,
          errorMessage = _this$props.errorMessage,
          fieldClassName = _this$props.fieldClassName,
          fieldRef = _this$props.fieldRef,
          focusTrigger = _this$props.focusTrigger,
          hint = _this$props.hint,
          inputRef = _this$props.inputRef,
          inversed = _this$props.inversed,
          label = _this$props.label,
          labelClassName = _this$props.labelClassName,
          options = _this$props.options,
          requirementLabel = _this$props.requirementLabel,
          size = _this$props.size,
          selectProps = _objectWithoutProperties(_this$props, ["ariaLabel", "className", "children", "errorMessage", "fieldClassName", "fieldRef", "focusTrigger", "hint", "inputRef", "inversed", "label", "labelClassName", "options", "requirementLabel", "size"]);
      /* eslint-enable prefer-const */


      var classes = (0, _classnames.default)(className);
      var fieldClasses = (0, _classnames.default)('ds-c-field', {
        'ds-c-field--inverse': inversed
      }, size && "ds-c-field--".concat(size), fieldClassName);
      var optionElements = options.map(function (option) {
        return _react.default.createElement("option", {
          key: option.value,
          value: option.value
        }, option.label);
      });
      return _react.default.createElement("div", {
        className: classes
      }, _react.default.createElement(_FormLabel.default, {
        className: labelClassName,
        component: 'label',
        errorMessage: errorMessage,
        fieldId: this.id(),
        hint: hint,
        requirementLabel: requirementLabel,
        inversed: inversed
      }, label), _react.default.createElement("select", _extends({
        "aria-label": ariaLabel,
        className: fieldClasses,
        id: this.id()
        /* eslint-disable no-return-assign */
        ,
        ref: function ref(_ref) {
          if (focusTrigger) {
            _this2.focusRef = _ref;
          } else {
            if (inputRef) {
              inputRef(_ref);
            }

            if (fieldRef) {
              fieldRef(_ref);
            }
          }
        }
        /* eslint-enable no-return-assign */

      }, selectProps),
      /* Render custom options if provided */
      children || optionElements));
    }
  }]);

  return Dropdown;
}(_react.default.PureComponent);

exports.Dropdown = Dropdown;
Dropdown.propTypes = {
  /**
   * Adds `aria-label` attribute. When using `aria-label`, `label` should be empty string.
   */
  ariaLabel: _propTypes.default.string,

  /**
   * Additional classes to be added to the root element.
   */
  className: _propTypes.default.string,

  /**
   * Used to define custom dropdown options (i.e. option groups). When using the `children` prop, `options` should be an empty list.
   */
  children: _propTypes.default.node,

  /**
   * Sets the initial selected state. Use this for an uncontrolled component;
   * otherwise, use the `value` property.
   */
  defaultValue: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]),

  /**
   * Disables the entire field.
   */
  disabled: _propTypes.default.bool,
  errorMessage: _propTypes.default.node,

  /**
   * Additional classes to be added to the select element
   */
  fieldClassName: _propTypes.default.string,

  /**
   * @hide-prop [Deprecated] Access a reference to the `select` element. Please use `inputRef` instead.
   */
  fieldRef: _propTypes.default.func,

  /**
   * Used to focus `select` on `componentDidMount()`
   */
  focusTrigger: _propTypes.default.bool,

  /**
   * Additional hint text to display
   */
  hint: _propTypes.default.node,

  /**
   * A unique ID to be used for the dropdown field. If one isn't provided, a unique ID will be generated.
   */
  id: _propTypes.default.string,

  /**
   * Access a reference to the `select` element
   */
  inputRef: _propTypes.default.func,

  /**
   * Applies the "inverse" UI theme
   */
  inversed: _propTypes.default.bool,

  /**
   * Label for the field. If using `Dropdown` without a label, provide an empty string for `label` and use the `ariaLabel` prop instead.
   */
  label: _propTypes.default.node.isRequired,

  /**
   * Additional classes to be added to the `FormLabel`.
   */
  labelClassName: _propTypes.default.string,

  /**
   * The field's `name` attribute
   */
  name: _propTypes.default.string.isRequired,

  /**
   * The list of options to be rendered. Provide an empty list if using custom options via the `children` prop.
   */
  options: _propTypes.default.arrayOf(_propTypes.default.shape({
    label: _propTypes.default.node.isRequired,
    value: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string]).isRequired
  })).isRequired,
  onBlur: _propTypes.default.func,
  onChange: _propTypes.default.func,

  /**
   * Text showing the requirement ("Required", "Optional", etc.). See [Required and Optional Fields]({{root}}/guidelines/forms/#required-and-optional-fields).
   */
  requirementLabel: _propTypes.default.node,

  /**
   * If the component renders a select, set the max-width of the input either to `'small'` or `'medium'`.
   */
  size: _propTypes.default.oneOf(['small', 'medium']),

  /**
   * Sets the field's `value`. Use this in combination with `onChange`
   * for a controlled component; otherwise, set `defaultValue`.
   */
  value: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.string])
};
var _default = Dropdown;
exports.default = _default;